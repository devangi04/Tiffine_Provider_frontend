import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Alert,
  ActivityIndicator,
  RefreshControl,
  TextInput,
  Modal,
  StatusBar,
} from 'react-native';
import { Text } from '@/components/ztext';
import { useLocalSearchParams, useRouter, useNavigation } from 'expo-router';
import { 
  ChevronLeft, 
  Download, 
  ArrowLeft, 
  ArrowRight, 
  IndianRupee,
  CheckCircle, 
  XCircle, 
  Clock, 
  Calendar, 
  Info,
  Mail,
  Utensils,
  Moon,
  Sun,
  Star
} from 'lucide-react-native';
import api from './api/api';
import moment from 'moment';
import { API_URL } from './config/env';

const API_BASE_URL = `${API_URL}/api`;

interface Customer {
  id: string;
  name: string;
  phone: string;
  email?: string;
}

interface Payment {
  amount: number;
  paidOn: string | Date;
  method: 'cash' | 'upi' | 'other';
}

interface MealBreakdown {
  date: string;
  mealType: 'lunch' | 'dinner';
  price: number;
  isSpecialPrice: boolean;
  menuId?: string;
}

interface BillingStats {
  totalMeals: number;
  lunchCount: number;
  dinnerCount: number;
  regularPriceCount: number;
  specialPriceCount: number;
  lunchAmount: number;
  dinnerAmount: number;
  specialPriceAmount: number;
}

interface Bill {
  id?: string;
  _id?: string;
  customer: Customer;
  providerId?: string;
  period: {
    start: string;
    end: string;
    month: string;
    year: string;
  };
  stats: BillingStats;
  billing: {
    totalAmount: number;
    breakdown: MealBreakdown[];
  };
  payments: Payment[];
  paidAmount: number;
  remainingAmount: number;
  isFullyPaid: boolean;
  emailSent?: boolean;
  emailSentAt?: string;
  autoGenerated?: boolean;
  tiffinCount?: number;
}

interface ApiErrorResponse {
  message?: string;
  success?: boolean;
  data?: any;
}

// Helper function to safely get nested values
const getSafeValue = (obj: any, path: string, defaultValue: any = 0) => {
  if (!obj) return defaultValue;
  
  try {
    const value = path.split('.').reduce((acc, part) => {
      if (acc === null || acc === undefined) return undefined;
      return acc[part];
    }, obj);
    
    if (value === undefined || value === null) {
      if (path.includes('email')) return '';
      if (path.includes('Amount')) return 0;
      if (path.includes('Count')) return 0;
      return defaultValue;
    }
    
    return value;
  } catch (error) {
    return defaultValue;
  }
};

const BillScreen = () => {
  const params = useLocalSearchParams();
  const { customerId } = params;
  const router = useRouter();
  
  const [bill, setBill] = useState<Bill | null>(null);
  const [loading, setLoading] = useState(true); // Start with loading true for first load
  const [error, setError] = useState<string | null>(null);
  const [refreshing, setRefreshing] = useState(false);
  const [currentMonth, setCurrentMonth] = useState(moment().month() + 1);
  const [currentYear, setCurrentYear] = useState(moment().year());
  const [paymentMethod, setPaymentMethod] = useState<'cash' | 'upi' | 'other'>('upi');
  const [paymentAmount, setPaymentAmount] = useState('');
  const [showPaymentModal, setShowPaymentModal] = useState(false);
  const [billNotFound, setBillNotFound] = useState(false);
  const [generatingBill, setGeneratingBill] = useState(false);
  const [isFetching, setIsFetching] = useState(false); // Separate state for fetching

const [sendingEmail, setSendingEmail] = useState(false);
const [sendingPayment, setSendingPayment] = useState(false);
  // Refs to prevent race conditions
  const abortControllerRef = useRef<AbortController | null>(null);
  const isMountedRef = useRef(true);
  const currentMonthYearRef = useRef(`${currentYear}-${currentMonth}`);
  const previousBillRef = useRef<Bill | null>(null); // Track previous bill

  const navigation = useNavigation();
  
  useEffect(() => {
    navigation.setOptions({
      headerShown: false,
    });
    
    return () => {
      isMountedRef.current = false;
      // Abort any pending requests on unmount
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, [navigation]);

  // Add proper type checking
  if (!customerId) {
    return (
      <View style={styles.container}>
        <StatusBar barStyle="dark-content" backgroundColor="#fff" />
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>Customer ID is required</Text>
          <TouchableOpacity
            style={styles.retryButton}
            onPress={() => router.back()}
          >
            <Text style={styles.retryButtonText}>Go Back</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  }

  const fetchBill = async (forceRefresh = false) => {
    const monthYearKey = `${currentYear}-${currentMonth}`;
    
    // Don't fetch if we're already fetching for this month
    if (currentMonthYearRef.current === monthYearKey && !forceRefresh && !loading) {
      return;
    }
    
    // Abort previous request if it exists
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    
    // Create new AbortController
    abortControllerRef.current = new AbortController();
    currentMonthYearRef.current = monthYearKey;
    
    try {
      // Set fetching state to true
      setIsFetching(true);
      
      // Clear previous bill data BEFORE fetching new data
      // This is the key fix - clear immediately when month changes
      setBill(null);
      setError(null);
      setBillNotFound(false);
      
      // Only show main loading on first load
      if (forceRefresh || !previousBillRef.current) {
        setLoading(true);
      }

      const response = await api.get(
        `${API_BASE_URL}/bills/customers/${customerId}/${currentYear}/${currentMonth}`,
        { 
          signal: abortControllerRef.current.signal,
          timeout: 10000 // Add timeout
        }
      );

      if (!isMountedRef.current) return;

      if (response.data.success) {
        const billData = response.data.data;
        
        // Calculate meal statistics from breakdown
        const billingBreakdown = billData.billing?.breakdown || [];
        const lunchItems = billingBreakdown.filter((item: MealBreakdown) => item.mealType === 'lunch');
        const dinnerItems = billingBreakdown.filter((item: MealBreakdown) => item.mealType === 'dinner');
        const specialPriceItems = billingBreakdown.filter((item: MealBreakdown) => item.isSpecialPrice);
        
        const safeBillData: Bill = {
          id: billData.id || billData._id || `${customerId}-${currentYear}-${currentMonth}`,
          customer: billData.customer || { 
            id: String(customerId), 
            name: 'Unknown', 
            phone: 'N/A',
            email: billData.customer?.email || ''
          },
          providerId: billData.providerId,
          period: billData.period || { 
            start: new Date(currentYear, currentMonth - 1, 1).toISOString(), 
            end: new Date(currentYear, currentMonth, 0).toISOString(),
            month: String(currentMonth),
            year: String(currentYear)
          },
          stats: {
            totalMeals: billData.stats?.totalMeals || billingBreakdown.length,
            lunchCount: billData.stats?.lunchCount || lunchItems.length,
            dinnerCount: billData.stats?.dinnerCount || dinnerItems.length,
            regularPriceCount: billData.stats?.regularPriceCount || (billingBreakdown.length - specialPriceItems.length),
            specialPriceCount: billData.stats?.specialPriceCount || specialPriceItems.length,
            lunchAmount: billData.stats?.lunchAmount || lunchItems.reduce((sum: number, item: MealBreakdown) => sum + item.price, 0),
            dinnerAmount: billData.stats?.dinnerAmount || dinnerItems.reduce((sum: number, item: MealBreakdown) => sum + item.price, 0),
            specialPriceAmount: billData.stats?.specialPriceAmount || specialPriceItems.reduce((sum: number, item: MealBreakdown) => sum + item.price, 0)
          },
          billing: billData.billing || { 
            totalAmount: 0, 
            breakdown: [] 
          },
          payments: billData.payments || [],
          paidAmount: billData.paidAmount || 0,
          remainingAmount: billData.remainingAmount || billData.dueAmount || (billData.billing?.totalAmount || 0),
          isFullyPaid: billData.isFullyPaid || false,
          emailSent: billData.emailSent || false,
          emailSentAt: billData.emailSentAt,
          autoGenerated: billData.autoGenerated || false,
          tiffinCount: billData.tiffinCount || billingBreakdown.length
        };
        
        setBill(safeBillData);
        previousBillRef.current = safeBillData;
      } else {
        setError(response.data.message || 'Failed to fetch bill details');
      }
    } catch (err: any) {
      // Ignore abort errors
      if (err.name === 'AbortError' || err.name === 'CanceledError' || err.code === 'ERR_CANCELED') {
        return;
      }
      
      if (!isMountedRef.current) return;
      
      if (err.response?.status === 404) {
        setBillNotFound(true);
        setBill(null); // Ensure bill is null
      } else if (err.code === 'NETWORK_ERROR' || err.message?.includes('Network')) {
        setError('Network error. Please check your connection and try again.');
      } else if (err.code === 'ECONNABORTED' || err.message?.includes('timeout')) {
        setError('Request timeout. Please try again.');
      } else {
        setError(
          err.response?.data?.message || 
          err.message || 
          'Unable to load bill details. Please try again.'
        );
      }
    } finally {
      if (isMountedRef.current) {
        setLoading(false);
        setIsFetching(false);
        setRefreshing(false);
      }
    }
  };

  useEffect(() => {
    fetchBill();
  }, [currentMonth, currentYear]);

  const handleMonthChange = (direction: 'prev' | 'next') => {
    // Clear all states immediately when month changes
    setBill(null);
    setError(null);
    setBillNotFound(false);
    setLoading(true); // Show loading immediately
    
    if (direction === 'prev') {
      if (currentMonth === 1) {
        setCurrentMonth(12);
        setCurrentYear(currentYear - 1);
      } else {
        setCurrentMonth(currentMonth - 1);
      }
    } else {
      if (currentMonth === 12) {
        setCurrentMonth(1);
        setCurrentYear(currentYear + 1);
      } else {
        setCurrentMonth(currentMonth + 1);
      }
    }
  };

  const onRefresh = () => {
    setRefreshing(true);
    fetchBill(true);
  };

  const downloadBill = async () => {
    Alert.alert('Download', 'Bill download functionality would be implemented here');
  };

const handlePayment = async () => {
  if (!bill) {
    Alert.alert('Error', 'No bill data available');
    return;
  }

  try {
    setSendingPayment(true); // Start loading for payment
    
    const amount = parseFloat(paymentAmount) || bill.remainingAmount;
    
    const customerId = bill.customer.id;
    const year = bill.period.year;
    const month = bill.period.month;

    const response = await api.post(
      `${API_BASE_URL}/bills/customers/${customerId}/${year}/${month}/payments`,
      {
        amount,
        method: paymentMethod
      },
      { timeout: 10000 } // Add timeout
    );
    
    if (response.data.success) {
      // ... rest of your existing success handling ...
      
      setShowPaymentModal(false);
      setPaymentAmount('');
      Alert.alert('Success', 'Payment recorded successfully');
    } else {
      throw new Error(response.data.message || 'Payment failed');
    }
  } catch (err: any) {
    Alert.alert(
      'Payment Error',
      err.message || 'Failed to record payment'
    );
  } finally {
    setSendingPayment(false); // Stop loading
  }
};
  const generateBillForCurrentMonth = async () => {
    try {
      setGeneratingBill(true);
      
      const response = await api.post(
        `${API_BASE_URL}/bills/generate-all/${currentYear}/${currentMonth}`
      );

      if (response.data.success) {
        Alert.alert(
          'Success', 
          `Generated ${response.data.data.billsGenerated} bills for ${moment().month(currentMonth - 1).format('MMMM YYYY')}`
        );
        // Refresh the bill
        fetchBill(true);
      } else {
        throw new Error(response.data.message || 'Failed to generate bills');
      }
    } catch (err: any) {
      Alert.alert(
        'Generation Error',
        err.message || 'Failed to generate bills'
      );
    } finally {
      setGeneratingBill(false);
    }
  };

const sendBillEmail = async () => {
  if (!bill?.id) {
    Alert.alert('Error', 'No bill available to send');
    return;
  }

  try {
    setSendingEmail(true); // Start loading
    
    const response = await api.post(
      `${API_BASE_URL}/bills/send-email/${bill.id}`,
      {}, // Add empty object if needed
      { timeout: 15000 } // Add timeout
    );
    
    if (response.data.success) {
      Alert.alert('Success', 'Bill email sent successfully');
      // Refresh bill to update email status
      fetchBill(true);
    } else {
      throw new Error(response.data.message || 'Failed to send email');
    }
  } catch (err: any) {
    Alert.alert(
      'Email Error',
      err.message || 'Failed to send bill email'
    );
  } finally {
    setSendingEmail(false); // Stop loading
  }
};

  // Check if current month is in the future or bill not generated yet
  const isCurrentMonth = currentMonth === moment().month() + 1 && currentYear === moment().year();
  const isFutureMonth = moment(`${currentYear}-${currentMonth}`, 'YYYY-M').isAfter(moment(), 'month');

  // Render Bill Not Generated View
  const renderBillNotGenerated = () => {
    const isLastDayOfMonth = moment().date() === moment().endOf('month').date();
    const isFirstWeekOfMonth = moment().date() <= 7;
    
    let message = "";
    let actionText = "";
    
    if (isFutureMonth) {
      message = "This is a future month. Bill will be generated automatically on the last day of the month.";
      actionText = "";
    } else if (isLastDayOfMonth) {
      message = "Bills are being generated today! Please check back in a few hours.";
      actionText = "Bills generate automatically today";
    } else if (isFirstWeekOfMonth) {
      message = "Bills for last month are being generated. They will be available soon.";
      actionText = "Bills are processing";
    } else {
      message = "Bill for this month is not generated yet. Bills are automatically generated on the last day of each month.";
      actionText = "Auto-generates end of month";
    }

    return (
      <View style={styles.container}>
        <StatusBar barStyle="dark-content" backgroundColor="#fff" />
        {/* Header */}
        <View style={styles.header}>
          <TouchableOpacity onPress={() => router.back()} style={styles.backButton}>
            <ChevronLeft size={24} color="#1E293B" />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>Monthly Bill</Text>
          <View style={{ width: 24 }} />
        </View>

        <ScrollView
          contentContainerStyle={[styles.contentContainer, { paddingTop: 0 }]}
          refreshControl={
            <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
          }
        >
          {/* Month Selector */}
          <View style={styles.monthSelector}>
            <TouchableOpacity onPress={() => handleMonthChange('prev')}>
              <ArrowLeft size={24} color="#4F46E5" />
            </TouchableOpacity>
            
            <Text style={styles.monthText}>
              {moment().month(currentMonth - 1).format('MMMM YYYY')}
            </Text>
            
            <TouchableOpacity 
              onPress={() => handleMonthChange('next')}
              disabled={isCurrentMonth}
            >
              <ArrowRight 
                size={24} 
                color={isCurrentMonth ? '#CBD5E1' : '#4F46E5'} 
              />
            </TouchableOpacity>
          </View>

          {/* Bill Not Generated Card */}
          <View style={styles.emptyCard}>
            <Calendar size={48} color="#94A3B8" />
            <Text style={styles.emptyTitle}>Bill Not Available</Text>
            <Text style={styles.emptyText}>
              {message}
            </Text>
            
            {actionText && (
              <View style={styles.statusBadge}>
                <Text style={styles.statusText}>{actionText}</Text>
              </View>
            )}
            
            <View style={styles.infoCard}>
              <Text style={styles.infoTitle}>Automatic Billing System</Text>
              <Text style={styles.infoText}>• Bills generate automatically on last day of month</Text>
              <Text style={styles.infoText}>• Email notifications are sent to customers</Text>
              <Text style={styles.infoText}>• Payments can be made after bill generation</Text>
              <Text style={styles.infoText}>• Previous bills are always available</Text>
            </View>

            {!isFutureMonth && (
              <TouchableOpacity 
                style={styles.generateBillButton}
                onPress={generateBillForCurrentMonth}
                disabled={generatingBill}
              >
                {generatingBill ? (
                  <ActivityIndicator size="small" color="#fff" />
                ) : (
                  <>
                    <Calendar size={18} color="#fff" />
                    <Text style={styles.generateBillButtonText}>Generate Bill Now</Text>
                  </>
                )}
              </TouchableOpacity>
            )}

            <TouchableOpacity 
              style={styles.viewPreviousButton}
              onPress={() => handleMonthChange('prev')}
            >
              <ArrowLeft size={18} color="#4F46E5" />
              <Text style={styles.viewPreviousButtonText}>View Previous Month Bill</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </View>
    );
  };

  // Render Payment Card (only when bill exists)
  const renderPaymentCard = () => {
    if (!bill || !bill.payments) return null;

    const payments = bill.payments || [];
    const lastPaymentDate = payments.length > 0 
      ? moment(payments[payments.length - 1].paidOn).format('MMM D, YYYY')
      : 'N/A';

    return (
      <View style={styles.paymentCard}>
        <View style={styles.paymentHeader}>
          <Text style={styles.cardTitle}>Payment Status</Text>
        {!bill.emailSent && bill.id && (
  <TouchableOpacity 
    style={[styles.emailButton, sendingEmail && styles.disabledButton]}
    onPress={sendBillEmail}
    disabled={sendingEmail}
  >
    {sendingEmail ? (
      <ActivityIndicator size={16} color="#4F46E5" />
    ) : (
      <>
        <Mail size={16} color="#4F46E5" />
        <Text style={styles.emailButtonText}>
          {sendingEmail ? 'Sending...' : 'Send Email'}
        </Text>
      </>
    )}
  </TouchableOpacity>
)}
        </View>
        
        {/* Email Status */}
        {bill.emailSent && (
          <View style={styles.emailStatus}>
            <CheckCircle size={16} color="#10B981" />
            <Text style={styles.emailStatusText}>
              Bill emailed on {moment(bill.emailSentAt).format('MMM D, YYYY')}
            </Text>
          </View>
        )}
        
        {bill.isFullyPaid ? (
          <View style={styles.paymentStatus}>
            <View style={[styles.statusBadge, styles.paidBadge]}>
              <Text style={[styles.statusText, styles.paidStatusText]}>Paid</Text>
            </View>
            <Text style={styles.dueDateText}>
              Paid on {lastPaymentDate}
            </Text>
          </View>
        ) : (
          <>
            <View style={styles.paymentStatus}>
              <View style={[styles.statusBadge, payments.length > 0 ? styles.partialBadge : styles.unpaidBadge]}>
                <Text style={[styles.statusText, payments.length > 0 ? styles.partialStatusText : styles.unpaidStatusText]}>
                  {payments.length > 0 ? 'Partial' : 'Unpaid'}
                </Text>
              </View>
              <Text style={styles.dueDateText}>
                Due by {moment(bill.period?.end).add(7, 'days').format('MMM D, YYYY')}
              </Text>
            </View>
            
            <View style={styles.paymentProgress}>
              <Text style={styles.paymentText}>
                Paid: ₹{(getSafeValue(bill, 'paidAmount', 0)).toFixed(2)} of ₹{(getSafeValue(bill, 'billing.totalAmount', 0)).toFixed(2)}
              </Text>
              <Text style={styles.paymentText}>
                Remaining: ₹{(getSafeValue(bill, 'remainingAmount', 0)).toFixed(2)}
              </Text>
              <Text style={styles.paymentDetail}>
                {getSafeValue(bill, 'stats.totalMeals')} meals • 
                {getSafeValue(bill, 'stats.lunchCount')} lunch • 
                {getSafeValue(bill, 'stats.dinnerCount')} dinner
              </Text>
            </View>
            
            <TouchableOpacity 
              style={styles.payButton}
              onPress={() => setShowPaymentModal(true)}
            >
              <IndianRupee size={18} color="#fff" />
              <Text style={styles.payButtonText}>
                {payments.length > 0 ? 'Add Payment' : 'Mark as Paid'}
              </Text>
            </TouchableOpacity>
          </>
        )}
      </View>
    );
  };

  // **FIXED: Show loading when loading and no bill (for month changes)**
  if (loading && !bill) {
    return (
      <View style={styles.container}>
        <StatusBar barStyle="dark-content" backgroundColor="#fff" />
        <View style={styles.header}>
          <TouchableOpacity onPress={() => router.back()} style={styles.backButton}>
            <ChevronLeft size={24} color="#1E293B" />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>Monthly Bill</Text>
          <View style={{ width: 24 }} />
        </View>
        
        <View style={styles.contentContainer}>
          {/* Month Selector should still be visible during loading */}
          <View style={styles.monthSelector}>
            <TouchableOpacity onPress={() => handleMonthChange('prev')}>
              <ArrowLeft size={24} color="#4F46E5" />
            </TouchableOpacity>
            
            <Text style={styles.monthText}>
              {moment().month(currentMonth - 1).format('MMMM YYYY')}
            </Text>
            
            <TouchableOpacity 
              onPress={() => handleMonthChange('next')}
              disabled={isCurrentMonth}
            >
              <ArrowRight 
                size={24} 
                color={isCurrentMonth ? '#CBD5E1' : '#4F46E5'} 
              />
            </TouchableOpacity>
          </View>
          
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color="#2c95f8" />
            <Text style={styles.loadingText}>Loading bill details...</Text>
          </View>
        </View>
      </View>
    );
  }

  // **FIXED: Show bill not generated view immediately when billNotFound is true**
  if (billNotFound) {
    return renderBillNotGenerated();
  }

  // Show other errors
  if (error && !billNotFound && !bill) {
    return (
      <View style={styles.container}>
        <StatusBar barStyle="dark-content" backgroundColor="#fff" />
        <View style={styles.header}>
          <TouchableOpacity onPress={() => router.back()} style={styles.backButton}>
            <ChevronLeft size={24} color="#1E293B" />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>Monthly Bill</Text>
          <View style={{ width: 24 }} />
        </View>
        
        <View style={styles.contentContainer}>
          <View style={styles.monthSelector}>
            <TouchableOpacity onPress={() => handleMonthChange('prev')}>
              <ArrowLeft size={24} color="#4F46E5" />
            </TouchableOpacity>
            
            <Text style={styles.monthText}>
              {moment().month(currentMonth - 1).format('MMMM YYYY')}
            </Text>
            
            <TouchableOpacity 
              onPress={() => handleMonthChange('next')}
              disabled={isCurrentMonth}
            >
              <ArrowRight 
                size={24} 
                color={isCurrentMonth ? '#CBD5E1' : '#4F46E5'} 
              />
            </TouchableOpacity>
          </View>
          
          <View style={styles.errorContainer}>
            <Text style={styles.errorText}>{error}</Text>
            <TouchableOpacity
              style={styles.retryButton}
              onPress={() => fetchBill(true)}
            >
              <Text style={styles.retryButtonText}>Retry</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    );
  }

  // **FIXED: This condition should not happen if we handle all cases above**
  if (!bill && !loading && !billNotFound) {
    return renderBillNotGenerated();
  }

  // **ONLY render normal bill view when bill exists AND loading is false**
  if (!bill) {
    // This should not happen, but as a fallback
    return (
      <View style={styles.container}>
        <StatusBar barStyle="dark-content" backgroundColor="#fff" />
        <View style={styles.header}>
          <TouchableOpacity onPress={() => router.back()} style={styles.backButton}>
            <ChevronLeft size={24} color="#1E293B" />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>Monthly Bill</Text>
          <View style={{ width: 24 }} />
        </View>
        
        <View style={styles.contentContainer}>
          <View style={styles.monthSelector}>
            <TouchableOpacity onPress={() => handleMonthChange('prev')}>
              <ArrowLeft size={24} color="#4F46E5" />
            </TouchableOpacity>
            
            <Text style={styles.monthText}>
              {moment().month(currentMonth - 1).format('MMMM YYYY')}
            </Text>
            
            <TouchableOpacity 
              onPress={() => handleMonthChange('next')}
              disabled={isCurrentMonth}
            >
              <ArrowRight 
                size={24} 
                color={isCurrentMonth ? '#CBD5E1' : '#4F46E5'} 
              />
            </TouchableOpacity>
          </View>
          
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color="#2c95f8" />
            <Text style={styles.loadingText}>Loading...</Text>
          </View>
        </View>
      </View>
    );
  }

  // Render normal bill view when bill exists
  return (
    <View style={styles.container}>
      <StatusBar barStyle="dark-content" backgroundColor="#fff" />
      {/* Header */}
      <View style={styles.header}>
        <TouchableOpacity onPress={() => router.back()} style={styles.backButton}>
          <ChevronLeft size={24} color="#1E293B" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Monthly Bill</Text>
        {/* <TouchableOpacity onPress={downloadBill}>
          <Download size={24} color="#4F46E5" />
        </TouchableOpacity> */}
      </View>

      <ScrollView
        contentContainerStyle={styles.contentContainer}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
      >
        {/* Month Selector */}
        <View style={styles.monthSelector}>
          <TouchableOpacity onPress={() => handleMonthChange('prev')}>
            <ArrowLeft size={24} color="#4F46E5" />
          </TouchableOpacity>
          
          <Text style={styles.monthText}>
            {moment().month(currentMonth - 1).format('MMMM YYYY')}
          </Text>
          
          <TouchableOpacity 
            onPress={() => handleMonthChange('next')}
            disabled={isCurrentMonth}
          >
            <ArrowRight 
              size={24} 
              color={isCurrentMonth ? '#CBD5E1' : '#4F46E5'} 
            />
          </TouchableOpacity>
        </View>

        {/* Show loading indicator over existing bill if we're refreshing */}
        {isFetching && bill && (
          <View style={styles.overlayLoading}>
            <ActivityIndicator size="large" color="#4F46E5" />
          </View>
        )}

        {/* Customer Info */}
        <View style={styles.customerCard}>
          <Text style={styles.cardTitle}>Customer Details</Text>
          <View style={styles.detailRow}>
            <Text style={styles.detailLabel}>Name:</Text>
            <Text style={styles.detailValue}>{getSafeValue(bill, 'customer.name', 'N/A')}</Text>
          </View>
          <View style={styles.detailRow}>
            <Text style={styles.detailLabel}>Phone:</Text>
            <Text style={styles.detailValue}>{getSafeValue(bill, 'customer.phone', 'N/A')}</Text>
          </View>
          {bill.customer.email && (
            <View style={styles.detailRow}>
              <Text style={styles.detailLabel}>Email:</Text>
              <Text style={styles.detailValue}>{bill.customer.email}</Text>
            </View>
          )}
          <View style={styles.detailRow}>
            <Text style={styles.detailLabel}>Billing Period:</Text>
            <Text style={styles.detailValue}>
              {moment(bill.period?.start).format('MMM D')} - {moment(bill.period?.end).format('MMM D, YYYY')}
            </Text>
          </View>
          {bill.autoGenerated && (
            <View style={styles.autoGeneratedBadge}>
              <Text style={styles.autoGeneratedText}>Auto-Generated</Text>
            </View>
          )}
        </View>

        {/* Consumption Stats */}
        <View style={styles.statsCard}>
          <Text style={styles.cardTitle}>Meal Consumption</Text>
          
          <View style={styles.statRow}>
            <View style={styles.statItem}>
              <CheckCircle size={20} color="#10B981" />
              <Text style={[styles.statValue, styles.statYes]}>
                {getSafeValue(bill, 'stats.totalMeals')}
              </Text>
              <Text style={styles.statLabel}>Total Meals</Text>
            </View>
            
            <View style={styles.statItem}>
              <Sun size={20} color="#f99613ff" />
              <Text style={[styles.statValue, styles.statLunch]}>
                {getSafeValue(bill, 'stats.lunchCount')}
              </Text>
              <Text style={styles.statLabel}>Lunch</Text>
            </View>
            
            <View style={styles.statItem}>
              <Moon size={20} color="#8B5CF6" />
              <Text style={[styles.statValue, styles.statDinner]}>
                {getSafeValue(bill, 'stats.dinnerCount')}
              </Text>
              <Text style={styles.statLabel}>Dinner</Text>
            </View>
          </View>

          {/* Special Pricing Info */}
          {getSafeValue(bill, 'stats.specialPriceCount', 0) > 0 && (
            <View style={styles.specialPriceBadge}>
              <Star size={16} color="#f5260bff" />
              <Text style={styles.specialPriceText}>
                {getSafeValue(bill, 'stats.specialPriceCount')} meals with special pricing
              </Text>
            </View>
          )}
        </View>

        {/* Bill Summary */}
        <View style={styles.billCard}>
          <Text style={styles.cardTitle}>Bill Summary</Text>
          
          {/* Meal Type Breakdown */}
          <View style={styles.breakdownSection}>
            <Text style={styles.breakdownTitle}>Meal Breakdown</Text>
            
            <View style={styles.breakdownRow}>
              <View style={styles.breakdownLabelContainer}>
                <Sun size={14} color="#F59E0B" />
                <Text style={styles.breakdownLabel}>
                  Lunch ({getSafeValue(bill, 'stats.lunchCount')} meals):
                </Text>
              </View>
              <Text style={styles.breakdownValue}>
                ₹{(getSafeValue(bill, 'stats.lunchAmount', 0)).toFixed(2)}
              </Text>
            </View>
            
            <View style={styles.breakdownRow}>
              <View style={styles.breakdownLabelContainer}>
                <Moon size={14} color="#8B5CF6" />
                <Text style={styles.breakdownLabel}>
                  Dinner ({getSafeValue(bill, 'stats.dinnerCount')} meals):
                </Text>
              </View>
              <Text style={styles.breakdownValue}>
                ₹{(getSafeValue(bill, 'stats.dinnerAmount', 0)).toFixed(2)}
              </Text>
            </View>
            
            {getSafeValue(bill, 'stats.specialPriceCount', 0) > 0 && (
              <View style={styles.breakdownRow}>
                <View style={styles.breakdownLabelContainer}>
                  <Star size={14} color="#f5260bff" />
                  <Text style={styles.breakdownLabel}>
                    Special Pricing ({getSafeValue(bill, 'stats.specialPriceCount')} meals):
                  </Text>
                </View>
                <Text style={styles.breakdownValue}>
                  ₹{(getSafeValue(bill, 'stats.specialPriceAmount', 0)).toFixed(2)}
                </Text>
              </View>
            )}
          </View>
          
          <View style={styles.divider} />
          
          <View style={[styles.billRow, styles.totalRow]}>
            <Text style={styles.totalLabel}>Total Amount:</Text>
            <Text style={styles.totalValue}>
              ₹{(getSafeValue(bill, 'billing.totalAmount', 0)).toFixed(2)}
            </Text>
          </View>
        </View>

        {/* Payment Status */}
        {renderPaymentCard()}

        {/* Payment History */}
        {bill.payments && bill.payments.length > 0 && (
          <View style={styles.paymentHistoryCard}>
            <Text style={styles.cardTitle}>Payment History</Text>
            {bill.payments.map((payment, index) => (
              <View key={index} style={styles.paymentItem}>
                <View style={styles.paymentInfo}>
                  <Text style={styles.paymentDate}>
                    {moment(payment.paidOn).format('MMM D, YYYY')}
                  </Text>
                  <Text style={styles.paymentMethod}>
                    {payment.method.toUpperCase()}
                  </Text>
                </View>
                <Text style={styles.paymentAmount}>
                  ₹{payment.amount.toFixed(2)}
                </Text>
              </View>
            ))}
          </View>
        )}
      </ScrollView>

      {/* Payment Modal */}
      <Modal
        visible={showPaymentModal}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setShowPaymentModal(false)}
      >
        <View style={styles.modalOverlay}>
          <StatusBar barStyle="light-content" backgroundColor="rgba(0,0,0,0.5)" />
          <View style={styles.modalContainer}>
            <Text style={styles.modalTitle}>Record Payment</Text>
            
            <View style={styles.inputGroup}>
              <Text style={styles.inputLabel}>Amount (₹)</Text>
              <TextInput
                style={styles.input}
                keyboardType="numeric"
                value={paymentAmount}
                onChangeText={setPaymentAmount}
                placeholder={`${bill.remainingAmount?.toFixed(2) || '0.00'}`}
              />
            </View>
            
            <View style={styles.inputGroup}>
              <Text style={styles.inputLabel}>Payment Method</Text>
              <View style={styles.methodButtons}>
                <TouchableOpacity
                  style={[
                    styles.methodButton,
                    paymentMethod === 'cash' && styles.methodButtonActive
                  ]}
                  onPress={() => setPaymentMethod('cash')}
                >
                  <Text style={[
                    styles.methodButtonText,
                    paymentMethod === 'cash' && styles.methodButtonTextActive
                  ]}>
                    Cash
                  </Text>
                </TouchableOpacity>
                
                <TouchableOpacity
                  style={[
                    styles.methodButton,
                    paymentMethod === 'upi' && styles.methodButtonActive
                  ]}
                  onPress={() => setPaymentMethod('upi')}
                >
                  <Text style={[
                    styles.methodButtonText,
                    paymentMethod === 'upi' && styles.methodButtonTextActive
                  ]}>
                    UPI
                  </Text>
                </TouchableOpacity>
                
                <TouchableOpacity
                  style={[
                    styles.methodButton,
                    paymentMethod === 'other' && styles.methodButtonActive
                  ]}
                  onPress={() => setPaymentMethod('other')}
                >
                  <Text style={[
                    styles.methodButtonText,
                    paymentMethod === 'other' && styles.methodButtonTextActive
                  ]}>
                    Other
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
            
            <View style={styles.modalButtons}>
              <TouchableOpacity
                style={[styles.modalButton, styles.cancelButton]}
                onPress={() => setShowPaymentModal(false)}
              >
                <Text style={styles.cancelButtonText}>Cancel</Text>
              </TouchableOpacity>
              
              <TouchableOpacity
                style={[styles.modalButton, styles.confirmButton]}
                onPress={handlePayment}
              >
                <Text style={styles.confirmButtonText}>Confirm</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    paddingTop: 45,
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#E2E8F0',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: '#1E293B',
  },
  contentContainer: {
    padding: 16,
    paddingBottom: 32,
    flexGrow: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    minHeight: 200,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#64748B',
  },
  overlayLoading: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(255, 255, 255, 0.8)',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 1000,
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    minHeight: 200,
  },
  errorText: {
    fontSize: 16,
    color: '#EF4444',
    marginBottom: 20,
    textAlign: 'center',
  },
  retryButton: {
    backgroundColor: '#4F46E5',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
  monthSelector: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
    marginTop: 10,
    paddingHorizontal: 8,
  },
  monthText: {
    fontSize: 18,
    fontWeight: '600',
    color: '#1E293B',
  },
  emptyCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 24,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    marginTop: 20,
  },
  emptyTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: '#1E293B',
    marginTop: 16,
    marginBottom: 8,
  },
  emptyText: {
    fontSize: 16,
    color: '#64748B',
    textAlign: 'center',
    marginBottom: 16,
    lineHeight: 22,
  },
  infoCard: {
    backgroundColor: '#F8FAFC',
    padding: 16,
    borderRadius: 8,
    marginBottom: 20,
    width: '100%',
  },
  infoTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
    marginBottom: 8,
  },
  infoText: {
    fontSize: 14,
    color: '#64748B',
    marginBottom: 4,
    lineHeight: 18,
  },
  statusBadge: {
    backgroundColor: '#E0E7FF',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
    marginBottom: 16,
  },
  statusText: {
    color: '#3730A3',
    fontSize: 12,
    fontWeight: '500',
  },
  generateBillButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#059669',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
    marginBottom: 16,
    width: '100%',
    justifyContent: 'center',
  },
  generateBillButtonText: {
    color: '#fff',
    fontWeight: '600',
    marginLeft: 8,
  },
  viewPreviousButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#EEF2FF',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
  },
  viewPreviousButtonText: {
    color: '#4F46E5',
    fontWeight: '600',
    marginLeft: 8,
  },
  customerCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  autoGeneratedBadge: {
    backgroundColor: '#F0FDF4',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
    alignSelf: 'flex-start',
    marginTop: 8,
  },
  autoGeneratedText: {
    color: '#065F46',
    fontSize: 12,
    fontWeight: '500',
  },
  statsCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  billCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  paymentCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  paymentHistoryCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  paymentHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  emailButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#EEF2FF',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 6,
  },
  emailButtonText: {
    color: '#4F46E5',
    fontSize: 12,
    fontWeight: '500',
    marginLeft: 4,
  },
  emailStatus: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#F0FDF4',
    padding: 8,
    borderRadius: 6,
    marginBottom: 12,
  },
  emailStatusText: {
    color: '#166534',
    fontSize: 12,
    marginLeft: 6,
  },
  cardTitle: {
    marginBottom: 12,
    fontSize: 18,
    fontWeight: '600',
    color: '#1E293B',
  },
  detailRow: {
    flexDirection: 'row',
    marginBottom: 8,
  },
  detailLabel: {
    width: 120,
    fontSize: 14,
    color: '#64748B',
  },
  detailValue: {
    flex: 1,
    fontSize: 14,
    fontWeight: '500',
    color: '#1E293B',
  },
  statRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  statItem: {
    alignItems: 'center',
    flex: 1,
  },
  statValue: {
    fontSize: 24,
    fontWeight: '600',
    marginVertical: 4,
  },
  statYes: {
    color: '#10B981',
  },
  statLunch: {
    color: '#F59E0B',
  },
  statDinner: {
    color: '#8B5CF6',
  },
  statLabel: {
    fontSize: 12,
    color: '#64748B',
    textAlign: 'center',
  },
  specialPriceBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#FFFBEB',
    padding: 8,
    borderRadius: 6,
    marginTop: 8,
    justifyContent: 'center',
  },
  specialPriceText: {
    color: '#f5260bff',
    fontSize: 12,
    fontWeight: '500',
    marginLeft: 4,
  },
  breakdownSection: {
    marginBottom: 12,
  },
  breakdownTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#374151',
    marginBottom: 8,
  },
  breakdownRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  breakdownLabelContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  breakdownLabel: {
    fontSize: 14,
    color: '#6B7280',
    marginLeft: 6,
  },
  breakdownValue: {
    fontSize: 14,
    fontWeight: '500',
    color: '#374151',
  },
  billRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  billLabel: {
    fontSize: 14,
    color: '#64748B',
  },
  billValue: {
    fontSize: 14,
    fontWeight: '500',
    color: '#1E293B',
  },
  divider: {
    height: 1,
    backgroundColor: '#E2E8F0',
    marginVertical: 12,
  },
  totalRow: {
    marginTop: 8,
  },
  totalLabel: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
  },
  totalValue: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
  },
  paymentStatus: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  unpaidBadge: {
    backgroundColor: '#FEE2E2',
  },
  partialBadge: {
    backgroundColor: '#FEF3C7',
  },
  paidBadge: {
    backgroundColor: '#D1FAE5',
  },
  unpaidStatusText: {
    color: '#B91C1C',
  },
  partialStatusText: {
    color: '#92400E',
  },
  paidStatusText: {
    color: '#065F46',
  },
  dueDateText: {
    fontSize: 14,
    color: '#64748B',
    marginLeft: 8,
  },
  paymentProgress: {
    marginVertical: 12,
  },
  paymentText: {
    fontSize: 14,
    color: '#64748B',
    marginBottom: 4,
  },
  paymentDetail: {
    fontSize: 12,
    color: '#94A3B8',
    marginTop: 2,
  },
  payButton: {
    flexDirection: 'row',
    backgroundColor: '#4F46E5',
    padding: 12,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 8,
  },
  payButtonText: {
    color: '#fff',
    fontWeight: '600',
    marginLeft: 8,
  },
  paymentItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#F1F5F9',
  },
  paymentInfo: {
    flex: 1,
  },
  paymentDate: {
    fontSize: 14,
    color: '#64748B',
  },
  paymentMethod: {
    fontSize: 12,
    color: '#94A3B8',
  },
  paymentAmount: {
    fontSize: 16,
    fontWeight: '600',
    color: '#10B981',
  },
  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  modalContainer: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 20,
    width: '90%',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: '600',
    marginBottom: 20,
    color: '#1E293B',
  },
  inputGroup: {
    marginBottom: 16,
  },
  inputLabel: {
    fontSize: 14,
    color: '#64748B',
    marginBottom: 8,
  },
  input: {
    borderWidth: 1,
    borderColor: '#E2E8F0',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
  },
  methodButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  methodButton: {
    borderWidth: 1,
    borderColor: '#E2E8F0',
    borderRadius: 8,
    padding: 12,
    flex: 1,
    marginHorizontal: 4,
  },
  methodButtonActive: {
    borderColor: '#4F46E5',
    backgroundColor: '#EEF2FF',
  },
  methodButtonText: {
    textAlign: 'center',
    color: '#64748B',
  },
  methodButtonTextActive: {
    color: '#4F46E5',
    fontWeight: '600',
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
  modalButton: {
    flex: 1,
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  cancelButton: {
    backgroundColor: '#F1F5F9',
    marginRight: 8,
  },
  confirmButton: {
    backgroundColor: '#4F46E5',
    marginLeft: 8,
  },
  cancelButtonText: {
    color: '#64748B',
    fontWeight: '600',
  },
  confirmButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
});

export default BillScreen;