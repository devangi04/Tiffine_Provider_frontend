import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Alert,
  ActivityIndicator,
  RefreshControl,
  TextInput,
  Modal,
  StatusBar,
} from 'react-native';
import { Text } from '@/components/ztext';
import { useLocalSearchParams, useRouter, useNavigation } from 'expo-router';
import { 
  ChevronLeft, 
  Download, 
  ArrowLeft, 
  ArrowRight, 
  IndianRupee,
  CheckCircle, 
  XCircle, 
  Clock, 
  Calendar, 
  Info,
  Mail,
  Utensils,
  Moon,
  Sun,
  Star
} from 'lucide-react-native';
import api from './api/api';
import moment from 'moment';
import { API_URL } from './config/env';
import { SafeAreaView } from 'react-native-safe-area-context';

const API_BASE_URL = `${API_URL}/api`;

interface Customer {
  id: string;
  name: string;
  phone: string;
  email?: string;
  registrationDate?: string; // Add this field
}

interface Payment {
  amount: number;
  paidOn: string | Date;
  method: 'cash' | 'upi' | 'other';
}

interface MealBreakdown {
  date: string;
  mealType: 'lunch' | 'dinner';
  price: number;
  isSpecialPrice: boolean;
  menuId?: string;
}

interface BillingStats {
  totalMeals: number;
  lunchCount: number;
  dinnerCount: number;
  regularPriceCount: number;
  specialPriceCount: number;
  lunchAmount: number;
  dinnerAmount: number;
  specialPriceAmount: number;
}

interface Bill {
  id?: string;
  _id?: string;
  customer: Customer;
  providerId?: string;
  period: {
    start: string;
    end: string;
    month: string;
    year: string;
  };
  stats: BillingStats;
  billing: {
    totalAmount: number;
    breakdown: MealBreakdown[];
  };
  payments: Payment[];
  paidAmount: number;
  remainingAmount: number;
  isFullyPaid: boolean;
  emailSent?: boolean;
  emailSentAt?: string;
  autoGenerated?: boolean;
  tiffinCount?: number;
  customerRegistrationDate?: string; // Add this field
}

interface ApiErrorResponse {
  message?: string;
  success?: boolean;
  data?: any;
}

// Helper function to safely get nested values
const getSafeValue = (obj: any, path: string, defaultValue: any = 0) => {
  if (!obj) return defaultValue;
  
  try {
    const value = path.split('.').reduce((acc, part) => {
      if (acc === null || acc === undefined) return undefined;
      return acc[part];
    }, obj);
    
    if (value === undefined || value === null) {
      if (path.includes('email')) return '';
      if (path.includes('Amount')) return 0;
      if (path.includes('Count')) return 0;
      return defaultValue;
    }
    
    return value;
  } catch (error) {
    return defaultValue;
  }
};

const BillScreen = () => {
  const params = useLocalSearchParams();
  const { customerId } = params;
  const router = useRouter();
  
  const [bill, setBill] = useState<Bill | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [refreshing, setRefreshing] = useState(false);
  const [currentMonth, setCurrentMonth] = useState(moment().month() + 1);
  const [currentYear, setCurrentYear] = useState(moment().year());
  const [paymentMethod, setPaymentMethod] = useState<'cash' | 'upi' | 'other'>('upi');
  const [paymentAmount, setPaymentAmount] = useState('');
  const [showPaymentModal, setShowPaymentModal] = useState(false);
  const [billNotFound, setBillNotFound] = useState(false);
  const [generatingBill, setGeneratingBill] = useState(false);
  const [isFetching, setIsFetching] = useState(false);
  const [sendingEmail, setSendingEmail] = useState(false);
  const [sendingPayment, setSendingPayment] = useState(false);
  
  // Store customer registration date
  const [customerRegistrationDate, setCustomerRegistrationDate] = useState<string | null>(null);
  
  // Refs to prevent race conditions
  const abortControllerRef = useRef<AbortController | null>(null);
  const isMountedRef = useRef(true);
  const currentMonthYearRef = useRef(`${currentYear}-${currentMonth}`);
  const previousBillRef = useRef<Bill | null>(null);

  const navigation = useNavigation();
  
  useEffect(() => {
    navigation.setOptions({
      headerShown: false,
    });
    
    return () => {
      isMountedRef.current = false;
      // Abort any pending requests on unmount
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, [navigation]);

  // Helper functions for date validation
  const isFutureMonth = (month: number, year: number): boolean => {
    const selectedDate = moment(`${year}-${month}`, 'YYYY-M');
    const today = moment();
    return selectedDate.isAfter(today, 'month');
  };

  const isBeforeCustomerRegistration = (month: number, year: number): boolean => {
    if (!customerRegistrationDate) return false;
    
    const selectedDate = moment(`${year}-${month}`, 'YYYY-M');
    const registrationMonth = moment(customerRegistrationDate).startOf('month');
    return selectedDate.isBefore(registrationMonth, 'month');
  };

  // Add proper type checking
  if (!customerId) {
    return (
      <View style={styles.container}>
        <StatusBar barStyle="dark-content" backgroundColor="transparent" />
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>Customer ID is required</Text>
          <TouchableOpacity
            style={styles.retryButton}
            onPress={() => router.back()}
          >
            <Text style={styles.retryButtonText}>Go Back</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  }

  const fetchBill = async (forceRefresh = false) => {
    // Check if date is in future
    if (isFutureMonth(currentMonth, currentYear)) {
      setError('Cannot view bills for future months');
      setLoading(false);
      setBill(null);
      setBillNotFound(true);
      return;
    }
    
    // Check if date is before customer registration
    if (isBeforeCustomerRegistration(currentMonth, currentYear)) {
      setError(`Customer was not registered in ${moment().month(currentMonth - 1).format('MMMM YYYY')}`);
      setLoading(false);
      setBill(null);
      setBillNotFound(true);
      return;
    }
    
    const monthYearKey = `${currentYear}-${currentMonth}`;
    
    // Don't fetch if we're already fetching for this month
    if (currentMonthYearRef.current === monthYearKey && !forceRefresh && !loading) {
      return;
    }
    
    // Abort previous request if it exists
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    
    // Create new AbortController
    abortControllerRef.current = new AbortController();
    currentMonthYearRef.current = monthYearKey;
    
    try {
      // Set fetching state to true
      setIsFetching(true);
      
      // Clear previous bill data BEFORE fetching new data
      setBill(null);
      setError(null);
      setBillNotFound(false);
      
      // Only show main loading on first load
      if (forceRefresh || !previousBillRef.current) {
        setLoading(true);
      }

      const response = await api.get(
        `${API_BASE_URL}/bills/customers/${customerId}/${currentYear}/${currentMonth}`,
        { 
          signal: abortControllerRef.current.signal,
          timeout: 10000
        }
      );

      if (!isMountedRef.current) return;

      if (response.data.success) {
        const billData = response.data.data;
        
        // Calculate meal statistics from breakdown
        const billingBreakdown = billData.billing?.breakdown || [];
        const lunchItems = billingBreakdown.filter((item: MealBreakdown) => item.mealType === 'lunch');
        const dinnerItems = billingBreakdown.filter((item: MealBreakdown) => item.mealType === 'dinner');
        const specialPriceItems = billingBreakdown.filter((item: MealBreakdown) => item.isSpecialPrice);
        
        const safeBillData: Bill = {
          id: billData.id || billData._id || `${customerId}-${currentYear}-${currentMonth}`,
          customer: billData.customer || { 
            id: String(customerId), 
            name: 'Unknown', 
            phone: 'N/A',
            email: billData.customer?.email || '',
            registrationDate: billData.customer?.registrationDate || billData.customer?.createdAt
          },
          providerId: billData.providerId,
          period: billData.period || { 
            start: new Date(currentYear, currentMonth - 1, 1).toISOString(), 
            end: new Date(currentYear, currentMonth, 0).toISOString(),
            month: String(currentMonth),
            year: String(currentYear)
          },
          stats: {
            totalMeals: billData.stats?.totalMeals || billingBreakdown.length,
            lunchCount: billData.stats?.lunchCount || lunchItems.length,
            dinnerCount: billData.stats?.dinnerCount || dinnerItems.length,
            regularPriceCount: billData.stats?.regularPriceCount || (billingBreakdown.length - specialPriceItems.length),
            specialPriceCount: billData.stats?.specialPriceCount || specialPriceItems.length,
            lunchAmount: billData.stats?.lunchAmount || lunchItems.reduce((sum: number, item: MealBreakdown) => sum + item.price, 0),
            dinnerAmount: billData.stats?.dinnerAmount || dinnerItems.reduce((sum: number, item: MealBreakdown) => sum + item.price, 0),
            specialPriceAmount: billData.stats?.specialPriceAmount || specialPriceItems.reduce((sum: number, item: MealBreakdown) => sum + item.price, 0)
          },
          billing: billData.billing || { 
            totalAmount: 0, 
            breakdown: [] 
          },
          payments: billData.payments || [],
          paidAmount: billData.paidAmount || 0,
          remainingAmount: billData.remainingAmount || billData.dueAmount || (billData.billing?.totalAmount || 0),
          isFullyPaid: billData.isFullyPaid || false,
          emailSent: billData.emailSent || false,
          emailSentAt: billData.emailSentAt,
          autoGenerated: billData.autoGenerated || false,
          tiffinCount: billData.tiffinCount || billingBreakdown.length,
          customerRegistrationDate: billData.customer?.registrationDate || billData.customer?.createdAt
        };
        
        // Store customer registration date from the first successful bill fetch
        if (safeBillData.customerRegistrationDate && !customerRegistrationDate) {
          setCustomerRegistrationDate(safeBillData.customerRegistrationDate);
        }
        
        setBill(safeBillData);
        previousBillRef.current = safeBillData;
      } else {
        setError(response.data.message || 'Failed to fetch bill details');
      }
    } catch (err: any) {
      // Ignore abort errors
      if (err.name === 'AbortError' || err.name === 'CanceledError' || err.code === 'ERR_CANCELED') {
        return;
      }
      
      if (!isMountedRef.current) return;
      
      if (err.response?.status === 404) {
        setBillNotFound(true);
        setBill(null);
      } else if (err.code === 'NETWORK_ERROR' || err.message?.includes('Network')) {
        setError('Network error. Please check your connection and try again.');
      } else if (err.code === 'ECONNABORTED' || err.message?.includes('timeout')) {
        setError('Request timeout. Please try again.');
      } else {
        setError(
          err.response?.data?.message || 
          err.message || 
          'Unable to load bill details. Please try again.'
        );
      }
    } finally {
      if (isMountedRef.current) {
        setLoading(false);
        setIsFetching(false);
        setRefreshing(false);
      }
    }
  };

  useEffect(() => {
    fetchBill();
  }, [currentMonth, currentYear]);

  
 const isBeforeRegistrationMonth = (month: number, year: number) => {
  if (!customerRegistrationDate) return true; // fallback if date missing

  const selected = moment({ year, month: month - 1 }).startOf('month');
  const registered = moment(customerRegistrationDate).startOf('month');

  return selected.isBefore(registered);
};

const handleMonthChange = (direction: 'prev' | 'next') => {
  if (!customerRegistrationDate) return; // safety check

  let newMonth = currentMonth;
  let newYear = currentYear;

  if (direction === 'prev') {
    // Calculate previous month/year
    if (currentMonth === 1) {
      newMonth = 12;
      newYear = currentYear - 1;
    } else {
      newMonth = currentMonth - 1;
    }

    // ðŸš« Block going before registration month
    const registrationMoment = moment(customerRegistrationDate).startOf('month');
    const selectedMoment = moment({ year: newYear, month: newMonth - 1 }).startOf('month');

    if (selectedMoment.isBefore(registrationMoment)) {
      Alert.alert(
        'No Bills Available',
        `Customer account was created in ${registrationMoment.format('MMMM YYYY')}.`,
        [{ text: 'OK' }]
      );
      return;
    }
  } else {
    // Calculate next month/year
    if (currentMonth === 12) {
      newMonth = 1;
      newYear = currentYear + 1;
    } else {
      newMonth = currentMonth + 1;
    }

    // ðŸš« Block future months
    if (isFutureMonth(newMonth, newYear)) {
      Alert.alert(
        'Future Date',
        'Cannot view bills for future months.',
        [{ text: 'OK' }]
      );
      return;
    }
  }

  // âœ… Clear states on valid change
  setBill(null);
  setError(null);
  setBillNotFound(false);
  setLoading(true);

  setCurrentMonth(newMonth);
  setCurrentYear(newYear);
};


  const onRefresh = () => {
    setRefreshing(true);
    fetchBill(true);
  };

  const downloadBill = async () => {
    Alert.alert('Download', 'Bill download functionality would be implemented here');
  };

  const handlePayment = async () => {
    if (!bill) {
      Alert.alert('Error', 'No bill data available');
      return;
    }

    try {
      setSendingPayment(true);
      
      const amount = parseFloat(paymentAmount) || bill.remainingAmount;
      
      const customerId = bill.customer.id;
      const year = bill.period.year;
      const month = bill.period.month;

      const response = await api.post(
        `${API_BASE_URL}/bills/customers/${customerId}/${year}/${month}/payments`,
        {
          amount,
          method: paymentMethod
        },
        { timeout: 10000 }
      );
      
      if (response.data.success) {
        setShowPaymentModal(false);
        setPaymentAmount('');
        Alert.alert('Success', 'Payment recorded successfully');
        fetchBill(true);
      } else {
        throw new Error(response.data.message || 'Payment failed');
      }
    } catch (err: any) {
      Alert.alert(
        'Payment Error',
        err.message || 'Failed to record payment'
      );
    } finally {
      setSendingPayment(false);
    }
  };

  const generateBillForCurrentMonth = async () => {
    try {
      setGeneratingBill(true);
      
      const response = await api.post(
        `${API_BASE_URL}/bills/generate-all/${currentYear}/${currentMonth}`
      );

      if (response.data.success) {
        Alert.alert(
          'Success', 
          `Generated ${response.data.data.billsGenerated} bills for ${moment().month(currentMonth - 1).format('MMMM YYYY')}`
        );
        fetchBill(true);
      } else {
        throw new Error(response.data.message || 'Failed to generate bills');
      }
    } catch (err: any) {
      Alert.alert(
        'Generation Error',
        err.message || 'Failed to generate bills'
      );
    } finally {
      setGeneratingBill(false);
    }
  };

  const sendBillEmail = async () => {
    if (!bill?.id) {
      Alert.alert('Error', 'No bill available to send');
      return;
    }

    try {
      setSendingEmail(true);
      
      const response = await api.post(
        `${API_BASE_URL}/bills/send-email/${bill.id}`,
        {},
        { timeout: 15000 }
      );
      
      if (response.data.success) {
        Alert.alert('Success', 'Bill email sent successfully');
        fetchBill(true);
      } else {
        throw new Error(response.data.message || 'Failed to send email');
      }
    } catch (err: any) {
      Alert.alert(
        'Email Error',
        err.message || 'Failed to send bill email'
      );
    } finally {
      setSendingEmail(false);
    }
  };

  // Render Month Selector with restrictions
  const renderMonthSelector = () => {
    const isCurrentMonth = currentMonth === moment().month() + 1 && currentYear === moment().year();
    const isFuture = isFutureMonth(currentMonth, currentYear);
    const isBeforeRegistration = isBeforeCustomerRegistration(currentMonth, currentYear);
    
    // Check if next month would be in future
    const nextMonth = currentMonth === 12 ? 1 : currentMonth + 1;
    const nextYear = currentMonth === 12 ? currentYear + 1 : currentYear;
    const isNextMonthFuture = isFutureMonth(nextMonth, nextYear);
    
    // Check if previous month would be before customer registration
    const prevMonth = currentMonth === 1 ? 12 : currentMonth - 1;
    const prevYear = currentMonth === 1 ? currentYear - 1 : currentYear;
    const isPrevMonthBeforeRegistration = isBeforeCustomerRegistration(prevMonth, prevYear);
    
    return (
      <View style={styles.monthSelector}>
        <TouchableOpacity 
          onPress={() => handleMonthChange('prev')}
          disabled={isPrevMonthBeforeRegistration}
          style={isPrevMonthBeforeRegistration && styles.disabledButton}
        >
          <ArrowLeft 
            size={24} 
            color={isPrevMonthBeforeRegistration ? '#CBD5E1' : '#4F46E5'} 
          />
        </TouchableOpacity>
        
        <View style={styles.monthTextContainer}>
          <Text style={styles.monthText}>
            {moment().month(currentMonth - 1).format('MMMM YYYY')}
          </Text>
          
          {/* Show indicator if date is in future */}
          {isFuture && (
            <View style={styles.futureDateIndicator}>
              <Text style={styles.futureDateText}>Future Month</Text>
            </View>
          )}
          
          {/* Show indicator if date is before customer registration */}
          {isBeforeRegistration && (
            <View style={styles.beforeRegistrationIndicator}>
              <Text style={styles.beforeRegistrationText}>
                Before Customer Registration
              </Text>
            </View>
          )}
        </View>
        
        <TouchableOpacity 
          onPress={() => handleMonthChange('next')}
          disabled={isCurrentMonth || isNextMonthFuture}
          style={(isCurrentMonth || isNextMonthFuture) && styles.disabledButton}
        >
          <ArrowRight 
            size={24} 
            color={(isCurrentMonth || isNextMonthFuture) ? '#CBD5E1' : '#4F46E5'} 
          />
        </TouchableOpacity>
      </View>
    );
  };

  // Render Bill Not Generated View
  const renderBillNotGenerated = () => {
    const isFuture = isFutureMonth(currentMonth, currentYear);
    const isBeforeRegistration = isBeforeCustomerRegistration(currentMonth, currentYear);
    const isLastDayOfMonth = moment().date() === moment().endOf('month').date();
    const isFirstWeekOfMonth = moment().date() <= 7;
    
    let message = "";
    let actionText = "";
    let showInfoCard = true;
    let showGenerateButton = true;
    
    if (isFuture) {
      message = "This is a future month. Bill will be generated automatically on the last day of the month.";
      actionText = "Future Month";
      showInfoCard = false;
      showGenerateButton = false;
    } else if (isBeforeRegistration) {
      message = customerRegistrationDate 
        ? `Customer was registered in ${moment(customerRegistrationDate).format('MMMM YYYY')}. No bills available before this date.`
        : 'No bills available before customer registration.';
      actionText = "Before Registration";
      showInfoCard = false;
      showGenerateButton = false;
    } else if (isLastDayOfMonth) {
      message = "Bills are being generated today! Please check back in a few hours.";
      actionText = "Bills generate automatically today";
    } else if (isFirstWeekOfMonth) {
      message = "Bills for last month are being generated. They will be available soon.";
      actionText = "Bills are processing";
    } else {
      message = "Bill for this month is not generated yet. Bills are automatically generated on the last day of each month.";
      actionText = "Auto-generates end of month";
    }

    return (
      <SafeAreaView  edges={['left', 'right', 'bottom']} style={styles.container}>
      

        <ScrollView
          contentContainerStyle={[styles.contentContainer]}
          refreshControl={
            <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
          }
        >
          {/* Month Selector */}
          {renderMonthSelector()}

          {/* Bill Not Generated Card */}
          <View style={styles.emptyCard}>
            <Calendar size={48} color="#94A3B8" />
            <Text style={styles.emptyTitle}>
              {isBeforeRegistration ? 'No Bills Available' : 
               isFuture ? 'Future Month' : 'Bill Not Available'}
            </Text>
            <Text style={styles.emptyText}>
              {message}
            </Text>
            
            {actionText && (
              <View style={[
                styles.statusBadge,
                (isFuture || isBeforeRegistration) && styles.statusBadgeWarning
              ]}>
                <Text style={[
                  styles.statusText,
                  (isFuture || isBeforeRegistration) && styles.statusTextWarning
                ]}>{actionText}</Text>
              </View>
            )}
            
            {showInfoCard && (
              <View style={styles.infoCard}>
                <Text style={styles.infoTitle}>Automatic Billing System</Text>
                <Text style={styles.infoText}>â€¢ Bills generate automatically on last day of month</Text>
                <Text style={styles.infoText}>â€¢ Email notifications are sent to customers</Text>
                <Text style={styles.infoText}>â€¢ Payments can be made after bill generation</Text>
                <Text style={styles.infoText}>â€¢ Previous bills are always available</Text>
              </View>
            )}

            {showGenerateButton && (
              <TouchableOpacity 
                style={styles.generateBillButton}
                onPress={generateBillForCurrentMonth}
                disabled={generatingBill}
              >
                {generatingBill ? (
                  <ActivityIndicator size="small" color="#fff" />
                ) : (
                  <>
                    <Calendar size={18} color="#fff" />
                    <Text style={styles.generateBillButtonText}>Generate Bill Now</Text>
                  </>
                )}
              </TouchableOpacity>
            )}

            {/* <TouchableOpacity 
              style={styles.viewPreviousButton}
              onPress={() => handleMonthChange('prev')}
              disabled={isBeforeCustomerRegistration(currentMonth - 1, currentYear)}
            >
              <ArrowLeft size={18} color="#4F46E5" />
              <Text style={styles.viewPreviousButtonText}>View Previous Month Bill</Text>
            </TouchableOpacity> */}
          </View>
        </ScrollView>
      </SafeAreaView>
    );
  };

  // Render Payment Card (only when bill exists)
  const renderPaymentCard = () => {
    if (!bill || !bill.payments) return null;

    const payments = bill.payments || [];
    const lastPaymentDate = payments.length > 0 
      ? moment(payments[payments.length - 1].paidOn).format('MMM D, YYYY')
      : 'N/A';

    return (
      <View style={styles.paymentCard}>
        <View style={styles.paymentHeader}>
          <Text style={styles.cardTitle}>Payment Status</Text>
          {!bill.emailSent && bill.id && (
            <TouchableOpacity 
              style={[styles.emailButton, sendingEmail && styles.disabledButton]}
              onPress={sendBillEmail}
              disabled={sendingEmail}
            >
              {sendingEmail ? (
                <ActivityIndicator size={16} color="#4F46E5" />
              ) : (
                <>
                  <Mail size={16} color="#4F46E5" />
                  <Text style={styles.emailButtonText}>
                    {sendingEmail ? 'Sending...' : 'Send Email'}
                  </Text>
                </>
              )}
            </TouchableOpacity>
          )}
        </View>
        
        {/* Email Status */}
        {bill.emailSent && (
          <View style={styles.emailStatus}>
            <CheckCircle size={16} color="#10B981" />
            <Text style={styles.emailStatusText}>
              Bill emailed on {moment(bill.emailSentAt).format('MMM D, YYYY')}
            </Text>
          </View>
        )}
        
        {bill.isFullyPaid ? (
          <View style={styles.paymentStatus}>
            <View style={[styles.statusBadge, styles.paidBadge]}>
              <Text style={[styles.statusText, styles.paidStatusText]}>Paid</Text>
            </View>
            <Text style={styles.dueDateText}>
              Paid on {lastPaymentDate}
            </Text>
          </View>
        ) : (
          <>
            <View style={styles.paymentStatus}>
              <View style={[styles.statusBadge, payments.length > 0 ? styles.partialBadge : styles.unpaidBadge]}>
                <Text style={[styles.statusText, payments.length > 0 ? styles.partialStatusText : styles.unpaidStatusText]}>
                  {payments.length > 0 ? 'Partial' : 'Unpaid'}
                </Text>
              </View>
              <Text style={styles.dueDateText}>
                Due by {moment(bill.period?.end).add(7, 'days').format('MMM D, YYYY')}
              </Text>
            </View>
            
            <View style={styles.paymentProgress}>
              <Text style={styles.paymentText}>
                Paid: â‚¹{(getSafeValue(bill, 'paidAmount', 0)).toFixed(2)} of â‚¹{(getSafeValue(bill, 'billing.totalAmount', 0)).toFixed(2)}
              </Text>
              <Text style={styles.paymentText}>
                Remaining: â‚¹{(getSafeValue(bill, 'remainingAmount', 0)).toFixed(2)}
              </Text>
              <Text style={styles.paymentDetail}>
                {getSafeValue(bill, 'stats.totalMeals')} meals â€¢ 
                {getSafeValue(bill, 'stats.lunchCount')} lunch â€¢ 
                {getSafeValue(bill, 'stats.dinnerCount')} dinner
              </Text>
            </View>
            
            <TouchableOpacity 
              style={styles.payButton}
              onPress={() =>{ setPaymentAmount(bill.remainingAmount.toFixed(2));
                setShowPaymentModal(true)}}
            >
              <IndianRupee size={18} color="#fff" />
              <Text style={styles.payButtonText}>
                {payments.length > 0 ? 'Add Payment' : 'Mark as Paid'}
              </Text>
            </TouchableOpacity>
          </>
        )}
      </View>
    );
  };

  // Show loading when loading and no bill
  if (loading && !bill) {
    return (
      <View style={styles.container}>
       
        
        <View style={styles.contentContainer}>
          {renderMonthSelector()}
          
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color="#2c95f8" />
            <Text style={styles.loadingText}>Loading bill details...</Text>
          </View>
        </View>
      </View>
    );
  }

  // Show bill not generated view
  if (billNotFound) {
    return renderBillNotGenerated();
  }

  // Show other errors
  if (error && !billNotFound && !bill) {
    return (
      <SafeAreaView style={styles.container}>
        <StatusBar barStyle="dark-content" backgroundColor="#fff" />
        <View style={styles.header}>
          <TouchableOpacity onPress={() => router.back()} style={styles.backButton}>
            <ChevronLeft size={24} color="#1E293B" />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>Monthly Bill</Text>
          <View style={{ width: 24 }} />
        </View>
        
        <View style={styles.contentContainer}>
          {renderMonthSelector()}
          
          <View style={styles.errorContainer}>
            <Text style={styles.errorText}>{error}</Text>
            <TouchableOpacity
              style={styles.retryButton}
              onPress={() => fetchBill(true)}
            >
              <Text style={styles.retryButtonText}>Retry</Text>
            </TouchableOpacity>
          </View>
        </View>
      </SafeAreaView>
    );
  }

  // Fallback condition
  if (!bill && !loading && !billNotFound) {
    return renderBillNotGenerated();
  }

  // Fallback loading
  if (!bill) {
    return (
      <View style={styles.container}>
        <StatusBar barStyle="dark-content" backgroundColor="#fff" />
   
        
        <View style={styles.contentContainer}>
          {renderMonthSelector()}
          
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color="#2c95f8" />
            <Text style={styles.loadingText}>Loading...</Text>
          </View>
        </View>
      </View>
    );
  }

  // Render normal bill view when bill exists
  return (
    <View style={styles.container}>
  

      <ScrollView
        contentContainerStyle={styles.contentContainer}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
      >
        {/* Month Selector */}
        {renderMonthSelector()}

        {/* Show loading indicator over existing bill if we're refreshing */}
        {isFetching && bill && (
          <View style={styles.overlayLoading}>
            <ActivityIndicator size="large" color="#4F46E5" />
          </View>
        )}

        {/* Customer Info */}
        <View style={styles.customerCard}>
          <Text style={styles.cardTitle}>Customer Details</Text>
          <View style={styles.detailRow}>
            <Text style={styles.detailLabel}>Name:</Text>
            <Text style={styles.detailValue}>{getSafeValue(bill, 'customer.name', 'N/A')}</Text>
          </View>
          <View style={styles.detailRow}>
            <Text style={styles.detailLabel}>Phone:</Text>
            <Text style={styles.detailValue}>{getSafeValue(bill, 'customer.phone', 'N/A')}</Text>
          </View>
          {bill.customer.email && (
            <View style={styles.detailRow}>
              <Text style={styles.detailLabel}>Email:</Text>
              <Text style={styles.detailValue}>{bill.customer.email}</Text>
            </View>
          )}
          {bill.customer.registrationDate && (
            <View style={styles.detailRow}>
              <Text style={styles.detailLabel}>Registered Since:</Text>
              <Text style={styles.detailValue}>
                {moment(bill.customer.registrationDate).format('MMM D, YYYY')}
              </Text>
            </View>
          )}
          <View style={styles.detailRow}>
            <Text style={styles.detailLabel}>Billing Period:</Text>
            <Text style={styles.detailValue}>
              {moment(bill.period?.start).format('MMM D')} - {moment(bill.period?.end).format('MMM D, YYYY')}
            </Text>
          </View>
          {bill.autoGenerated && (
            <View style={styles.autoGeneratedBadge}>
              <Text style={styles.autoGeneratedText}>Auto-Generated</Text>
            </View>
          )}
        </View>

        {/* Consumption Stats */}
        <View style={styles.statsCard}>
          <Text style={styles.cardTitle}>Meal Consumption</Text>
          
          <View style={styles.statRow}>
            <View style={styles.statItem}>
              <CheckCircle size={20} color="#10B981" />
              <Text style={[styles.statValue, styles.statYes]}>
                {getSafeValue(bill, 'stats.totalMeals')}
              </Text>
              <Text style={styles.statLabel}>Total Meals</Text>
            </View>
            
            <View style={styles.statItem}>
              <Sun size={20} color="#f99613ff" />
              <Text style={[styles.statValue, styles.statLunch]}>
                {getSafeValue(bill, 'stats.lunchCount')}
              </Text>
              <Text style={styles.statLabel}>Lunch</Text>
            </View>
            
            <View style={styles.statItem}>
              <Moon size={20} color="#8B5CF6" />
              <Text style={[styles.statValue, styles.statDinner]}>
                {getSafeValue(bill, 'stats.dinnerCount')}
              </Text>
              <Text style={styles.statLabel}>Dinner</Text>
            </View>
          </View>

          {/* Special Pricing Info */}
          {getSafeValue(bill, 'stats.specialPriceCount', 0) > 0 && (
            <View style={styles.specialPriceBadge}>
              <Star size={16} color="#f5260bff" />
              <Text style={styles.specialPriceText}>
                {getSafeValue(bill, 'stats.specialPriceCount')} meals with special pricing
              </Text>
            </View>
          )}
        </View>

        {/* Bill Summary */}
        <View style={styles.billCard}>
          <Text style={styles.cardTitle}>Bill Summary</Text>
          
          {/* Meal Type Breakdown */}
          <View style={styles.breakdownSection}>
            <Text style={styles.breakdownTitle}>Meal Breakdown</Text>
            
            <View style={styles.breakdownRow}>
              <View style={styles.breakdownLabelContainer}>
                <Sun size={14} color="#F59E0B" />
                <Text style={styles.breakdownLabel}>
                  Lunch ({getSafeValue(bill, 'stats.lunchCount')} meals):
                </Text>
              </View>
              <Text style={styles.breakdownValue}>
                â‚¹{(getSafeValue(bill, 'stats.lunchAmount', 0)).toFixed(2)}
              </Text>
            </View>
            
            <View style={styles.breakdownRow}>
              <View style={styles.breakdownLabelContainer}>
                <Moon size={14} color="#8B5CF6" />
                <Text style={styles.breakdownLabel}>
                  Dinner ({getSafeValue(bill, 'stats.dinnerCount')} meals):
                </Text>
              </View>
              <Text style={styles.breakdownValue}>
                â‚¹{(getSafeValue(bill, 'stats.dinnerAmount', 0)).toFixed(2)}
              </Text>
            </View>
            
            {getSafeValue(bill, 'stats.specialPriceCount', 0) > 0 && (
              <View style={styles.breakdownRow}>
                <View style={styles.breakdownLabelContainer}>
                  <Star size={14} color="#f5260bff" />
                  <Text style={styles.breakdownLabel}>
                    Special Pricing ({getSafeValue(bill, 'stats.specialPriceCount')} meals):
                  </Text>
                </View>
                <Text style={styles.breakdownValue}>
                  â‚¹{(getSafeValue(bill, 'stats.specialPriceAmount', 0)).toFixed(2)}
                </Text>
              </View>
            )}
          </View>
          
          <View style={styles.divider} />
          
          <View style={[styles.billRow, styles.totalRow]}>
            <Text style={styles.totalLabel}>Total Amount:</Text>
            <Text style={styles.totalValue}>
              â‚¹{(getSafeValue(bill, 'billing.totalAmount', 0)).toFixed(2)}
            </Text>
          </View>
        </View>

        {/* Payment Status */}
        {renderPaymentCard()}

        {/* Payment History */}
        {bill.payments && bill.payments.length > 0 && (
          <View style={styles.paymentHistoryCard}>
            <Text style={styles.cardTitle}>Payment History</Text>
            {bill.payments.map((payment, index) => (
              <View key={index} style={styles.paymentItem}>
                <View style={styles.paymentInfo}>
                  <Text style={styles.paymentDate}>
                    {moment(payment.paidOn).format('MMM D, YYYY')}
                  </Text>
                  <Text style={styles.paymentMethod}>
                    {payment.method.toUpperCase()}
                  </Text>
                </View>
                <Text style={styles.paymentAmount}>
                  â‚¹{payment.amount.toFixed(2)}
                </Text>
              </View>
            ))}
          </View>
        )}
      </ScrollView>

      {/* Payment Modal */}
      <Modal
        visible={showPaymentModal}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setShowPaymentModal(false)}
      >
        <View style={styles.modalOverlay}>
          <StatusBar barStyle="light-content" backgroundColor="rgba(0,0,0,0.5)" />
          <View style={styles.modalContainer}>
            <Text style={styles.modalTitle}>Record Payment</Text>
            
            <View style={styles.inputGroup}>
              <Text style={styles.inputLabel}>Amount (â‚¹)</Text>
              <TextInput
                style={styles.input}
                keyboardType="numeric"
                editable={false}
                value={paymentAmount}
                onChangeText={setPaymentAmount}
                
              />
            </View>
            
            <View style={styles.inputGroup}>
              <Text style={styles.inputLabel}>Payment Method</Text>
              <View style={styles.methodButtons}>
                <TouchableOpacity
                  style={[
                    styles.methodButton,
                    paymentMethod === 'cash' && styles.methodButtonActive
                  ]}
                  onPress={() => setPaymentMethod('cash')}
                >
                  <Text style={[
                    styles.methodButtonText,
                    paymentMethod === 'cash' && styles.methodButtonTextActive
                  ]}>
                    Cash
                  </Text>
                </TouchableOpacity>
                
                <TouchableOpacity
                  style={[
                    styles.methodButton,
                    paymentMethod === 'upi' && styles.methodButtonActive
                  ]}
                  onPress={() => setPaymentMethod('upi')}
                >
                  <Text style={[
                    styles.methodButtonText,
                    paymentMethod === 'upi' && styles.methodButtonTextActive
                  ]}>
                    UPI
                  </Text>
                </TouchableOpacity>
                
                <TouchableOpacity
                  style={[
                    styles.methodButton,
                    paymentMethod === 'other' && styles.methodButtonActive
                  ]}
                  onPress={() => setPaymentMethod('other')}
                >
                  <Text style={[
                    styles.methodButtonText,
                    paymentMethod === 'other' && styles.methodButtonTextActive
                  ]}>
                    Other
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
            
            <View style={styles.modalButtons}>
              <TouchableOpacity
                style={[styles.modalButton, styles.cancelButton]}
                onPress={() => setShowPaymentModal(false)}
              >
                <Text style={styles.cancelButtonText}>Cancel</Text>
              </TouchableOpacity>
              
              <TouchableOpacity
                style={[styles.modalButton, styles.confirmButton]}
                onPress={handlePayment}
                disabled={sendingPayment}
              >
                {sendingPayment ? (
                  <ActivityIndicator size="small" color="#fff" />
                ) : (
                  <Text style={styles.confirmButtonText}>Confirm</Text>
                )}
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#E2E8F0',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: '#1E293B',
  },
  contentContainer: {
    padding: 16,
    paddingBottom: 112,
    flexGrow: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    minHeight: 200,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#64748B',
  },
  overlayLoading: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(255, 255, 255, 0.8)',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 1000,
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    minHeight: 200,
  },
  errorText: {
    fontSize: 16,
    color: '#EF4444',
    marginBottom: 20,
    textAlign: 'center',
  },
  retryButton: {
    backgroundColor: '#4F46E5',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
  monthSelector: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
    marginTop: 10,
    paddingHorizontal: 8,
  },
  monthTextContainer: {
    alignItems: 'center',
  },
  monthText: {
    fontSize: 18,
    fontWeight: '600',
    color: '#1E293B',
  },
  futureDateIndicator: {
    backgroundColor: '#EFF6FF',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 6,
    marginTop: 4,
    borderWidth: 1,
    borderColor: '#BFDBFE',
  },
  futureDateText: {
    fontSize: 10,
    color: '#1D4ED8',
    fontWeight: '500',
  },
  beforeRegistrationIndicator: {
    backgroundColor: '#FEF2F2',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 6,
    marginTop: 4,
    borderWidth: 1,
    borderColor: '#FECACA',
  },
  beforeRegistrationText: {
    fontSize: 10,
    color: '#DC2626',
    fontWeight: '500',
  },
  disabledButton: {
    opacity: 0.5,
  },
  emptyCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 24,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    marginTop: 20,
  },
  emptyTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: '#1E293B',
    marginTop: 16,
    marginBottom: 8,
  },
  emptyText: {
    fontSize: 16,
    color: '#64748B',
    textAlign: 'center',
    marginBottom: 16,
    lineHeight: 22,
  },
  infoCard: {
    backgroundColor: '#F8FAFC',
    padding: 16,
    borderRadius: 8,
    marginBottom: 20,
    width: '100%',
  },
  infoTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
    marginBottom: 8,
  },
  infoText: {
    fontSize: 14,
    color: '#64748B',
    marginBottom: 4,
    lineHeight: 18,
  },
  statusBadge: {
    backgroundColor: '#E0E7FF',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
    marginBottom: 16,
  },
  statusBadgeWarning: {
    backgroundColor: '#FEF3C7',
  },
  statusText: {
    color: '#3730A3',
    fontSize: 12,
    fontWeight: '500',
  },
  statusTextWarning: {
    color: '#92400E',
  },
  generateBillButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#059669',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
    marginBottom: 16,
    width: '100%',
    justifyContent: 'center',
  },
  generateBillButtonText: {
    color: '#fff',
    fontWeight: '600',
    marginLeft: 8,
  },
  viewPreviousButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#EEF2FF',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
  },
  viewPreviousButtonText: {
    color: '#4F46E5',
    fontWeight: '600',
    marginLeft: 8,
  },
  customerCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  autoGeneratedBadge: {
    backgroundColor: '#F0FDF4',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
    alignSelf: 'flex-start',
    marginTop: 8,
  },
  autoGeneratedText: {
    color: '#065F46',
    fontSize: 12,
    fontWeight: '500',
  },
  statsCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  billCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  paymentCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  paymentHistoryCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  paymentHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  emailButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#EEF2FF',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 6,
  },
  emailButtonText: {
    color: '#4F46E5',
    fontSize: 12,
    fontWeight: '500',
    marginLeft: 4,
  },
  emailStatus: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#F0FDF4',
    padding: 8,
    borderRadius: 6,
    marginBottom: 12,
  },
  emailStatusText: {
    color: '#166534',
    fontSize: 12,
    marginLeft: 6,
  },
  cardTitle: {
    marginBottom: 12,
    fontSize: 18,
    fontWeight: '600',
    color: '#1E293B',
  },
  detailRow: {
    flexDirection: 'row',
    marginBottom: 8,
  },
  detailLabel: {
    width: 120,
    fontSize: 14,
    color: '#64748B',
  },
  detailValue: {
    flex: 1,
    fontSize: 14,
    fontWeight: '500',
    color: '#1E293B',
  },
  statRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  statItem: {
    alignItems: 'center',
    flex: 1,
  },
  statValue: {
    fontSize: 24,
    fontWeight: '600',
    marginVertical: 4,
  },
  statYes: {
    color: '#10B981',
  },
  statLunch: {
    color: '#F59E0B',
  },
  statDinner: {
    color: '#8B5CF6',
  },
  statLabel: {
    fontSize: 12,
    color: '#64748B',
    textAlign: 'center',
  },
  specialPriceBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#FFFBEB',
    padding: 8,
    borderRadius: 6,
    marginTop: 8,
    justifyContent: 'center',
  },
  specialPriceText: {
    color: '#f5260bff',
    fontSize: 12,
    fontWeight: '500',
    marginLeft: 4,
  },
  breakdownSection: {
    marginBottom: 12,
  },
  breakdownTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#374151',
    marginBottom: 8,
  },
  breakdownRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  breakdownLabelContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  breakdownLabel: {
    fontSize: 14,
    color: '#6B7280',
    marginLeft: 6,
  },
  breakdownValue: {
    fontSize: 14,
    fontWeight: '500',
    color: '#374151',
  },
  billRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  billLabel: {
    fontSize: 14,
    color: '#64748B',
  },
  billValue: {
    fontSize: 14,
    fontWeight: '500',
    color: '#1E293B',
  },
  divider: {
    height: 1,
    backgroundColor: '#E2E8F0',
    marginVertical: 12,
  },
  totalRow: {
    marginTop: 8,
  },
  totalLabel: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
  },
  totalValue: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
  },
  paymentStatus: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  unpaidBadge: {
    backgroundColor: '#FEE2E2',
  },
  partialBadge: {
    backgroundColor: '#FEF3C7',
  },
  paidBadge: {
    backgroundColor: '#D1FAE5',
  },
  unpaidStatusText: {
    color: '#B91C1C',
  },
  partialStatusText: {
    color: '#92400E',
  },
  paidStatusText: {
    color: '#065F46',
  },
  dueDateText: {
    fontSize: 14,
    color: '#64748B',
    marginLeft: 8,
  },
  paymentProgress: {
    marginVertical: 12,
  },
  paymentText: {
    fontSize: 14,
    color: '#64748B',
    marginBottom: 4,
  },
  paymentDetail: {
    fontSize: 12,
    color: '#94A3B8',
    marginTop: 2,
  },
  payButton: {
    flexDirection: 'row',
    backgroundColor: '#15803d',
    padding: 12,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 8,
  },
  payButtonText: {
    color: '#fff',
    fontWeight: '600',
    marginLeft: 8,
  },
  paymentItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#F1F5F9',
  },
  paymentInfo: {
    flex: 1,
  },
  paymentDate: {
    fontSize: 14,
    color: '#64748B',
  },
  paymentMethod: {
    fontSize: 12,
    color: '#94A3B8',
  },
  paymentAmount: {
    fontSize: 16,
    fontWeight: '600',
    color: '#10B981',
  },
  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  modalContainer: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 20,
    width: '90%',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: '600',
    marginBottom: 20,
    color: '#1E293B',
  },
  inputGroup: {
    marginBottom: 16,
  },
  inputLabel: {
    fontSize: 14,
    color: '#64748B',
    marginBottom: 8,
  },
  input: {
    borderWidth: 1,
    borderColor: '#E2E8F0',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
  },
  methodButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  methodButton: {
    borderWidth: 1,
    borderColor: '#E2E8F0',
    borderRadius: 8,
    padding: 12,
    flex: 1,
    marginHorizontal: 4,
  },
  methodButtonActive: {
    borderColor: '#4F46E5',
    backgroundColor: '#EEF2FF',
  },
  methodButtonText: {
    textAlign: 'center',
    color: '#64748B',
  },
  methodButtonTextActive: {
    color: '#4F46E5',
    fontWeight: '600',
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
  modalButton: {
    flex: 1,
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  cancelButton: {
    backgroundColor: '#F1F5F9',
    marginRight: 8,
  },
  confirmButton: {
    backgroundColor: '#4F46E5',
    marginLeft: 8,
  },
  cancelButtonText: {
    color: '#64748B',
    fontWeight: '600',
  },
  confirmButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
});

export default BillScreen;