import { API_URL } from '@/app/config/env';
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import axios from 'axios';

const API_BASE_URL = `${API_URL}/api`;

// Types - Keep as you have them
interface MealBreakdown {
  date: string;
  mealType: 'lunch' | 'dinner';
  price: number;
  isSpecialPrice: boolean;
  menuId?: string;
}

interface BillingStats {
  totalMeals: number;
  lunchCount: number;
  dinnerCount: number;
  regularPriceCount: number;
  specialPriceCount: number;
  lunchAmount: number;
  dinnerAmount: number;
  specialPriceAmount: number;
}

interface BillResponse {
  id?: string;
  _id?: string;
  customer: {
    id: string;
    name: string;
    phone: string;
    email?: string;
  };
  providerId?: string;
  period: {
    start: string;
    end: string;
    month: string;
    year: string;
  };
  stats: BillingStats;
  billing: {
    totalAmount: number;
    breakdown: MealBreakdown[];
  };
  payments: Array<{
    amount: number;
    paidOn: string | Date;
    method: 'cash' | 'upi' | 'other';
  }>;
  paidAmount: number;
  remainingAmount: number;
  isFullyPaid: boolean;
  emailSent?: boolean;
  emailSentAt?: string;
  autoGenerated?: boolean;
  tiffinCount?: number;
}

interface BillState {
  currentBills: BillResponse[];
  currentBill: BillResponse | null;
  loading: boolean;
  error: string | null;
}

const initialState: BillState = {
  currentBills: [],
  currentBill: null,
  loading: false,
  error: null,
};

// Thunks - UPDATED TO MATCH YOUR EXPRESS ROUTES

// If you need to fetch all bills for a customer, you might need to add this endpoint to your Express router
// Add this thunk to your billslice.ts if it doesn't exist
export const fetchCustomerBills = createAsyncThunk(
  'bills/fetchCustomerBills',
  async ({ customerId }: { customerId: string }, { rejectWithValue }) => {
    try {
      // Temporary: Get all bills and filter for this customer
      const response = await axios.get(`${API_BASE_URL}/bills/list`);
      
      if (response.data.success) {
        // Filter bills for this specific customer
        const customerBills = response.data.data.filter(
          (bill: any) => bill.customerId?._id === customerId || 
                       bill.customerId?.id === customerId ||
                       bill.customer?.id === customerId
        );
        
        // Format the bills to match your BillResponse type
        const formattedBills = customerBills.map((bill: any) => ({
          id: bill._id || bill.id,
          _id: bill._id,
          customer: {
            id: bill.customerId?._id || bill.customer?.id || customerId,
            name: bill.customerId?.name || bill.customer?.name || 'Unknown',
            phone: bill.customerId?.phone || bill.customer?.phone || '',
            email: bill.customerId?.email || bill.customer?.email
          },
          providerId: bill.providerId,
          period: bill.period || {
            start: new Date().toISOString(),
            end: new Date().toISOString(),
            month: bill.month ? bill.month.split('-')[1] : '1',
            year: bill.month ? bill.month.split('-')[0] : '2024'
          },
          stats: bill.stats || {
            totalMeals: bill.tiffinCount || 0,
            lunchCount: 0,
            dinnerCount: 0,
            regularPriceCount: 0,
            specialPriceCount: 0,
            lunchAmount: 0,
            dinnerAmount: 0,
            specialPriceAmount: 0
          },
          billing: bill.billing || {
            totalAmount: bill.totalAmount || 0,
            breakdown: bill.billingBreakdown || []
          },
          payments: bill.transactions || bill.payments || [],
          paidAmount: bill.paidAmount || 0,
          remainingAmount: bill.dueAmount || bill.remainingAmount || (bill.totalAmount || 0),
          isFullyPaid: bill.paymentStatus === 'paid' || bill.isFullyPaid || false,
          emailSent: bill.emailSent || false,
          emailSentAt: bill.emailSentAt,
          autoGenerated: bill.autoGenerated || false,
          tiffinCount: bill.tiffinCount || 0
        }));
        
        // Sort by month (newest first)
        formattedBills.sort((a: BillResponse, b: BillResponse) => {
          const dateA = new Date(a.period?.year || 0, (parseInt(a.period?.month || '1') - 1));
          const dateB = new Date(b.period?.year || 0, (parseInt(b.period?.month || '1') - 1));
          return dateB.getTime() - dateA.getTime();
        });
        
        return formattedBills;
      } else {
        return rejectWithValue(response.data.message || 'Failed to fetch bills');
      }
    } catch (err: any) {
      // Return empty array for 404 or network errors
      if (err.response?.status === 404) {
        return [];
      }
      return rejectWithValue(err.response?.data?.message || err.message || 'Network error');
    }
  }
);
export const fetchBillDetails = createAsyncThunk(
  'bills/fetchBillDetails',
  async ({ billId }: { billId: string }, { rejectWithValue }) => {
    try {
      const response = await axios.get(
        `${API_BASE_URL}/bills/${billId}`
      );
      
      if (response.data.success) {
        return response.data.data;
      } else {
        return rejectWithValue(response.data.message || 'Failed to fetch bill details');
      }
    } catch (err: any) {
      return rejectWithValue(err.response?.data?.message || err.message || 'Network error');
    }
  }
);

// CORRECTED: Match your Express route: GET /api/bills/customers/:customerId/:year/:month
export const fetchMonthlyBill = createAsyncThunk(
  'bills/fetchMonthlyBill',
  async ({ 
    customerId, 
    year, 
    month 
  }: { 
    customerId: string; 
    year: string | number; 
    month: string | number 
  }, { rejectWithValue }) => {
    try {
      const response = await axios.get(
        `${API_BASE_URL}/bills/customers/${customerId}/${year}/${month}`
      );
      
      if (response.data.success) {
        const billData = response.data.data;
        
        // Transform the data to match your BillResponse type
        const transformedBill: BillResponse = {
          id: billData.id || billData._id,
          customer: billData.customer || { 
            id: String(customerId), 
            name: 'Unknown', 
            phone: 'N/A',
            email: billData.customer?.email || ''
          },
          providerId: billData.providerId,
          period: billData.period || { 
            start: new Date(year as number, Number(month) - 1, 1).toISOString(), 
            end: new Date(year as number, Number(month), 0).toISOString(),
            month: String(month),
            year: String(year)
          },
          stats: billData.stats || {
            totalMeals: 0,
            lunchCount: 0,
            dinnerCount: 0,
            regularPriceCount: 0,
            specialPriceCount: 0,
            lunchAmount: 0,
            dinnerAmount: 0,
            specialPriceAmount: 0
          },
          billing: billData.billing || { 
            totalAmount: 0, 
            breakdown: [] 
          },
          payments: billData.payments || [],
          paidAmount: billData.paidAmount || 0,
          remainingAmount: billData.remainingAmount || billData.dueAmount || (billData.billing?.totalAmount || 0),
          isFullyPaid: billData.isFullyPaid || false,
          emailSent: billData.emailSent || false,
          emailSentAt: billData.emailSentAt,
          autoGenerated: billData.autoGenerated || false,
          tiffinCount: billData.tiffinCount || 0
        };
        
        return transformedBill;
      } else {
        return rejectWithValue(response.data.message || 'Failed to fetch monthly bill');
      }
    } catch (err: any) {
      // Handle 404 specifically
      if (err.response?.status === 404) {
        return rejectWithValue(`Bill not generated for ${new Date(year as number, Number(month) - 1).toLocaleString('default', { month: 'long', year: 'numeric' })}`);
      }
      return rejectWithValue(err.response?.data?.message || err.message || 'Network error');
    }
  }
);

// CORRECTED: Since your Express route uses GET for single customer bill generation
export const generateCustomerBill = createAsyncThunk(
  'bills/generateCustomerBill',
  async ({ 
    customerId,
    year = new Date().getFullYear(),
    month = new Date().getMonth() + 1
  }: { 
    customerId: string;
    year?: number;
    month?: number;
  }, { rejectWithValue }) => {
    try {
      // Using GET endpoint since your Express router has GET /customers/:customerId/:year/:month
      const response = await axios.get(
        `${API_BASE_URL}/bills/customers/${customerId}/${year}/${month}`
      );
      
      if (response.data.success) {
        return response.data.data;
      } else {
        return rejectWithValue(response.data.message || 'Failed to generate bill');
      }
    } catch (err: any) {
      return rejectWithValue(err.response?.data?.message || err.message || 'Network error');
    }
  }
);

// Generate bills for all customers (this matches your POST /generate-all/:year/:month route)
export const generateAllBills = createAsyncThunk(
  'bills/generateAllBills',
  async ({ 
    year = new Date().getFullYear(),
    month = new Date().getMonth() + 1
  }: { 
    year?: number;
    month?: number;
  }, { rejectWithValue }) => {
    try {
      const response = await axios.post(
        `${API_BASE_URL}/bills/generate-all/${year}/${month}`,
        {}
      );
      
      if (response.data.success) {
        return response.data.data;
      } else {
        return rejectWithValue(response.data.message || 'Failed to generate all bills');
      }
    } catch (err: any) {
      return rejectWithValue(err.response?.data?.message || err.message || 'Network error');
    }
  }
);

// CORRECTED: Match your Express route: POST /api/bills/customers/:customerId/:year/:month/payments
export const addPayment = createAsyncThunk(
  'bills/addPayment',
  async ({ 
    customerId,
    year,
    month,
    amount, 
    method = 'upi' 
  }: { 
    customerId: string;
    year: string | number;
    month: string | number;
    amount: number; 
    method?: 'cash' | 'upi' | 'other' 
  }, { rejectWithValue }) => {
    try {
      const response = await axios.post(
        `${API_BASE_URL}/bills/customers/${customerId}/${year}/${month}/payments`,
        { amount, method }
      );
      
      if (response.data.success) {
        return response.data.data;
      } else {
        return rejectWithValue(response.data.message || 'Failed to add payment');
      }
    } catch (err: any) {
      return rejectWithValue(err.response?.data?.message || err.message || 'Network error');
    }
  }
);

// CORRECTED: Match your Express route: POST /api/bills/send-email/:billId
export const sendBillEmail = createAsyncThunk(
  'bills/sendBillEmail',
  async (billId: string, { rejectWithValue }) => {
    try {
      const response = await axios.post(
        `${API_BASE_URL}/bills/send-email/${billId}`,
        {}
      );
      
      if (response.data.success) {
        return response.data.data;
      } else {
        return rejectWithValue(response.data.message || 'Failed to send email');
      }
    } catch (err: any) {
      return rejectWithValue(err.response?.data?.message || err.message || 'Network error');
    }
  }
);

// Get all bills (matches your GET /api/bills/list route)
export const fetchAllBills = createAsyncThunk(
  'bills/fetchAllBills',
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get(`${API_BASE_URL}/bills/list`);
      
      if (response.data.success) {
        return response.data.data;
      } else {
        return rejectWithValue(response.data.message || 'Failed to fetch all bills');
      }
    } catch (err: any) {
      return rejectWithValue(err.response?.data?.message || err.message || 'Network error');
    }
  }
);

// Get payment summary (matches your GET /api/bills/payment-summary route)
export const fetchPaymentSummary = createAsyncThunk(
  'bills/fetchPaymentSummary',
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get(`${API_BASE_URL}/bills/payment-summary`);
      
      if (response.data.success) {
        return response.data.data;
      } else {
        return rejectWithValue(response.data.message || 'Failed to fetch payment summary');
      }
    } catch (err: any) {
      return rejectWithValue(err.response?.data?.message || err.message || 'Network error');
    }
  }
);

const billsSlice = createSlice({
  name: 'bills',
  initialState,
  reducers: {
    clearCurrentBill: (state) => {
      state.currentBill = null;
      state.error = null;
    },
    clearCurrentBills: (state) => {
      state.currentBills = [];
      state.error = null;
    },
    clearBillError: (state) => {
      state.error = null;
    },
    resetBills: (state) => {
      state.currentBills = [];
      state.currentBill = null;
      state.loading = false;
      state.error = null;
    },
    // Add a manual setter if needed
    setCurrentBill: (state, action) => {
      state.currentBill = action.payload;
    },
  },
  extraReducers: (builder) => {
    builder
      // Fetch Customer Bills
      .addCase(fetchCustomerBills.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchCustomerBills.fulfilled, (state, action) => {
        state.loading = false;
        state.currentBills = action.payload;
        state.error = null;
      })
      .addCase(fetchCustomerBills.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
        state.currentBills = [];
      })

      // Fetch Bill Details
      .addCase(fetchBillDetails.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchBillDetails.fulfilled, (state, action) => {
        state.loading = false;
        state.currentBill = action.payload;
        state.error = null;
      })
      .addCase(fetchBillDetails.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
        state.currentBill = null;
      })

      // Fetch Monthly Bill
      .addCase(fetchMonthlyBill.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchMonthlyBill.fulfilled, (state, action) => {
        state.loading = false;
        state.currentBill = action.payload;
        state.error = null;
      })
      .addCase(fetchMonthlyBill.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
        state.currentBill = null;
      })

      // Generate Customer Bill
      .addCase(generateCustomerBill.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(generateCustomerBill.fulfilled, (state, action) => {
        state.loading = false;
        state.currentBill = action.payload;
        state.error = null;
      })
      .addCase(generateCustomerBill.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })

      // Generate All Bills
      .addCase(generateAllBills.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(generateAllBills.fulfilled, (state, action) => {
        state.loading = false;
        state.error = null;
      })
      .addCase(generateAllBills.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })

      // Add Payment
      .addCase(addPayment.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(addPayment.fulfilled, (state, action) => {
        state.loading = false;
        state.currentBill = action.payload;
        state.error = null;
      })
      .addCase(addPayment.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })

      // Send Bill Email
      .addCase(sendBillEmail.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(sendBillEmail.fulfilled, (state, action) => {
        state.loading = false;
        if (state.currentBill) {
          state.currentBill.emailSent = true;
          state.currentBill.emailSentAt = new Date().toISOString();
        }
        state.error = null;
      })
      .addCase(sendBillEmail.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })

      // Fetch All Bills
      .addCase(fetchAllBills.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchAllBills.fulfilled, (state, action) => {
        state.loading = false;
        state.currentBills = action.payload;
        state.error = null;
      })
      .addCase(fetchAllBills.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
        state.currentBills = [];
      })

      // Fetch Payment Summary
      .addCase(fetchPaymentSummary.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchPaymentSummary.fulfilled, (state, action) => {
        state.loading = false;
        state.error = null;
      })
      .addCase(fetchPaymentSummary.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      });
  },
});

export const {
  clearCurrentBill,
  clearCurrentBills,
  clearBillError,
  resetBills,
  setCurrentBill,
} = billsSlice.actions;

export default billsSlice.reducer;